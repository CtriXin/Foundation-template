{"version":3,"sources":["../../src/model/mongo.js"],"names":["getPk","pk","resolve","_createIndexes","storeKey","getTableName","isSet","thinkCache","TABLE","indexes","think","isEmpty","await","promises","key","value","isObject","options","val","k","slice","push","createIndex","all","then","parseOptions","oriOpts","extraOptions","extend","_options","table","tablePrefix","model","getModelName","optionsFilter","parseData","data","collection","db","add","_data","msg","Error","locale","reject","beforeAdd","afterAdd","getLastInsertId","thenAdd","where","find","findData","type","insertId","thenUpdate","update","addMany","isArray","err","delete","beforeDelete","afterDelete","result","n","ignoreDefault","isBoolean","beforeUpdate","afterUpdate","nModified","updateMany","dataList","map","reduce","a","b","select","beforeSelect","afterSelect","countSelect","pageFlag","count","isNumber","limit","config","nums_per_page","numsPerPage","currentPage","parseInt","totalPage","Math","ceil","totalPages","beforeFind","afterFind","increment","field","step","$inc","decrement","sum","aggregate","mapReduce","out","ensureIndex","getIndexes"],"mappings":"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","file":"mongo.js","sourcesContent":["'use strict';\n\nimport Base from './_base.js';\n\n/**\n * mongodb model\n */\nexport default class extends Base {\n  /**\n   * get primary key\n   * @return {Promise} []\n   */\n  getPk(){\n    this.pk = '_id';\n    return Promise.resolve(this.pk);\n  }\n  /**\n   * create index from this.indexes\n   * http://docs.mongodb.org/manual/core/indexes-introduction/\n   * @return {Promise} []\n   */\n  async _createIndexes(){\n    let storeKey = `mongo_${this.getTableName()}_indexes`;\n    let isSet = thinkCache(thinkCache.TABLE, storeKey);\n    if(isSet){\n      return;\n    }\n    let indexes = this.indexes;\n    if(think.isEmpty(indexes)){\n      return;\n    }\n\n    return think.await(storeKey, () => {\n      let promises = [];\n      for(let key in indexes){\n        let value = indexes[key];\n        if(think.isObject(value)){\n          let options = {};\n          let val = {};\n          for(let k in value){\n            //key start with $ is options\n            if(k[0] === '$'){\n              options[k.slice(1)] = value[k];\n            }else{\n              val[k] = value[k];\n            }\n          }\n          //if value is empty, auto add key itself\n          if(think.isEmpty(val)){\n            val[key] = 1;\n          }\n          promises.push(this.createIndex(val, options));\n        }else{\n          value = {[key]: value};\n          promises.push(this.createIndex(value));\n        }\n      }\n      return Promise.all(promises).then(() => {\n        thinkCache(thinkCache.TABLE, storeKey, 1);\n      });\n\n    });\n  }\n  /**\n   * parse options\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async parseOptions(oriOpts, extraOptions){\n    let options = think.extend({}, this._options);\n    if (think.isObject(oriOpts)) {\n      options = think.extend(options, oriOpts, extraOptions);\n    }\n    //clear options\n    this._options = {};\n    //get table name\n    options.table = options.table || this.getTableName();\n\n    options.tablePrefix = this.tablePrefix;\n    options.model = this.getModelName();\n\n    if(!think.isObject(oriOpts)){\n      options = think.extend(options, oriOpts, extraOptions);\n    }\n    \n    await this._createIndexes();\n\n    return this.optionsFilter(options);\n  }\n  /**\n   * parse data\n   * @param  {Object} data []\n   * @return {Object}      []\n   */\n  parseData(data){\n    return data;\n  }\n  /**\n   * get table connection\n   * @return {Promise} []\n   */\n  collection(table){\n    table = table || this.getTableName();\n    return this.db().collection(table);\n  }\n  /**\n   * add data\n   * @param {Object} data    []\n   * @param {Object} options []\n   */\n  async add(data, options){\n    //copy data\n    data = think.extend({}, this._data, data);\n    //clear data\n    this._data = {};\n    if (think.isEmpty(data)) {\n      let msg = new Error(think.locale('DATA_EMPTY'));\n      return think.reject(msg);\n    }\n    options = await this.parseOptions(options);\n    data = await this.beforeAdd(data, options);\n    data = this.parseData(data);\n    await this.db().add(data, options);\n    await this.afterAdd(data, options);\n    return this.db().getLastInsertId();\n  }\n   /**\n   * then add\n   * @param  {Object} data       []\n   * @param  {Object} where      []\n   * @return {}            []\n   */\n  async thenAdd(data, where){\n    let findData = await this.where(where).find();\n    if(!think.isEmpty(findData)){\n      return {[this.pk]: findData[this.pk], type: 'exist'};\n    }\n    let insertId = await this.add(data);\n    return {[this.pk]: insertId, type: 'add'};\n  }\n  /**\n   * update data when exist, otherwise add data\n   * @return {id}\n   */\n  async thenUpdate(data, where){\n    let findData = await this.where(where).find();\n    if(think.isEmpty(findData)){\n      return this.add(data);\n    }\n    await this.where(where).update(data);\n    return findData[this.pk];\n  }\n  /**\n   * add multi data\n   * @param {Object} data    []\n   * @param {} options []\n   * @param {} replace []\n   */\n  async addMany(data, options){\n    if (!think.isArray(data) || !think.isObject(data[0])) {\n      let err = new Error(think.locale('DATA_MUST_BE_ARRAY'));\n      return think.reject(err);\n    }\n    options = await this.parseOptions(options);\n    data = await this.beforeAdd(data, options);\n    await this.db().addMany(data, options);\n    await this.afterAdd(data, options);\n    return this.db().getLastInsertId();\n  }\n  /**\n   * delete data\n   * @return {} []\n   */\n  async delete(options){\n    options = await this.parseOptions(options);\n    options = await this.beforeDelete(options);\n    let data = await this.db().delete(options);\n    await this.afterDelete(options);\n    return data.result.n || 0;\n  }\n  /**\n   * update data\n   * @return {Promise} []\n   */\n  async update(data, options, ignoreDefault){\n    if(think.isBoolean(options)){\n      ignoreDefault = options;\n      options = {};\n    }\n    options = await this.parseOptions(options);\n    let pk = await this.getPk();\n    if(data[pk]){\n      this.where({[pk]: data[pk]});\n      delete data[pk];\n    }\n    if(ignoreDefault !== true){\n      data = await this.beforeUpdate(data, options);\n    }\n    let result = await this.db().update(data, options);\n    await this.afterUpdate(data, options);\n    return result.result.nModified || 0;\n  }\n  /**\n   * update many data\n   * @param  {Promise} dataList []\n   * @return {Promise}          []\n   */\n  async updateMany(dataList, options){\n    if (!think.isArray(dataList)) {\n      return think.reject(new Error(think.locale('DATA_MUST_BE_ARRAY')));\n    }\n    let promises = dataList.map(data => {\n      return this.update(data, options);\n    });\n    return Promise.all(promises).then(data => {\n      return data.reduce((a, b) => a + b);\n    });\n  }\n  /**\n   * select data\n   * @return {Promise} []\n   */\n  async select(options){\n    options = await this.parseOptions(options);\n    options = await this.beforeSelect(options);\n    let data = await this.db().select(options);\n    return this.afterSelect(data, options);\n  }\n  /**\n   * count select\n   * @param  {Object} options  []\n   * @param  {Boolean} pageFlag []\n   * @return {Promise}          []\n   */\n  async countSelect(options, pageFlag){\n    let count;\n    if (think.isBoolean(options)) {\n      pageFlag = options;\n      options = {};\n    }else if(think.isNumber(options)){\n      count = options;\n      options = {};\n    }\n\n    options = await this.parseOptions(options);\n    if(!count){\n      //get count\n      count = await this.options(options).count();\n    }\n\n    options.limit = options.limit || [0, this.config.nums_per_page];\n\n    let numsPerPage = options.limit[1];\n    //get page options\n    let data = {numsPerPage: numsPerPage};\n    data.currentPage = parseInt((options.limit[0] / options.limit[1]) + 1);\n    let totalPage = Math.ceil(count / data.numsPerPage);\n    if (think.isBoolean(pageFlag) && data.currentPage > totalPage) {\n      if(pageFlag){\n        data.currentPage = 1;\n        options.limit = [0, numsPerPage];\n      }else{\n        data.currentPage = totalPage;\n        options.limit = [(totalPage - 1) * numsPerPage, numsPerPage];\n      }\n    }\n    let result = think.extend({count: count, totalPages: totalPage}, data);\n    result.data = count ? await this.select(options) : [];\n    return result;\n  }\n  /**\n   * select one row data\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async find(options){\n    options = await this.parseOptions(options, {limit: 1});\n    options = await this.beforeFind(options);\n    let data = await this.db().select(options);\n    return this.afterFind(data[0] || {}, options);\n  }\n  /**\n   * increment field data\n   * @param  {String} field []\n   * @param  {Number} step  []\n   * @return {Promise}       []\n   */\n  async increment(field, step = 1){\n    let options = await this.parseOptions(options);\n    return this.db().update({\n      $inc: {\n        [field]: step\n      }\n    }, options).then(data => {\n      return data.result.n;\n    });\n  }\n  /**\n   * decrement field data\n   * @param  {String} field []\n   * @param  {Number} step  []\n   * @return {Promise}       []\n   */\n  async decrement(field, step = 1){\n    let options = await this.parseOptions(options);\n    return this.db().update({\n      $inc: {\n        [field]: 0 - step\n      }\n    }, options).then(data => {\n      return data.result.n;\n    });\n  }\n  /**\n   * get count \n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async count(field){\n    this.field(field);\n    let options = await this.parseOptions();\n    return this.db().count(options);\n  }\n  /**\n   * get sum\n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async sum(field){\n    this.field(field);\n    let options = await this.parseOptions();\n    return this.db().sum(options);\n  }\n  /**\n   * aggregate\n   * http://docs.mongodb.org/manual/reference/sql-aggregation-comparison/\n   * @param  {} options []\n   * @return {}         []\n   */\n  aggregate(options){\n    return this.db().aggregate(this.getTableName(), options);\n  }\n  /**\n   * map reduce\n   * Examples: http://docs.mongodb.org/manual/tutorial/map-reduce-examples/\n   * @param  {Function} map    []\n   * @param  {Function} reduce []\n   * @param  {Object} out    []\n   * @return {Promise}        []\n   */\n  mapReduce(map, reduce, out){\n    return this.collection().then(collection => {\n      return collection.mapReduce(map, reduce, out);\n    });\n  }\n  /**\n   * create indexes\n   * @param  {Object} indexes []\n   * @return {Promise}         []\n   */\n  createIndex(indexes, options){\n    return this.db().ensureIndex(this.getTableName(), indexes, options);\n  }\n  /**\n   * get collection indexes\n   * @return {Promise} []\n   */\n  getIndexes(){\n    return this.collection().then(collection => {\n      return collection.indexes();\n    });\n  }\n}\n"]}