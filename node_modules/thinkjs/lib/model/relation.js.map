{"version":3,"sources":["../../src/model/relation.js"],"names":["think","model","HAS_ONE","BELONG_TO","HAS_MANY","MANY_TO_MANY","init","name","config","relation","undefined","_relationName","setRelation","value","isObject","isEmpty","obj","extend","isBoolean","isString","split","filterRelations","filter","indexOf","item","afterFind","data","options","getRelation","afterSelect","getPk","pk","promises","map","key","type","opts","fKey","itemData","isArray","relData","modelOpts","cache","forEach","isFunction","optItem","getModelName","_getBelongsToRelation","_getHasManyRelation","_getManyToManyRelation","_getHasOneRelation","all","mapOpts","where","parseRelationWhere","select","mapData","parseRelationData","sql","field","db","parseField","join","table","rModel","tablePrefix","getRelationTableName","table1","getTableName","where1","parseWhere","rkey","rfKey","where2","trim","slice","parseSql","tableName","toLowerCase","getRelationModel","keys","isArrMap","i","mapItem","push","afterAdd","postRelation","afterDelete","afterUpdate","postType","_postBelongsToRelation","_postHasManyRelation","_postManyToManyRelation","_postHasOneRelation","add","delete","update","addMany","getSchema","then","catch","relationModel","firstItem","isNumberString","postData","getUniqueField","unqiueField","reject","Error","_getRalationAddIds","ids","id","dataList","find","insertId","base"],"mappings":"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","file":"relation.js","sourcesContent":["'use strict';\n\n//model relation type\nthink.model.HAS_ONE = 1;\nthink.model.BELONG_TO = 2;\nthink.model.HAS_MANY = 3;\nthink.model.MANY_TO_MANY = 4;\n/**\n * relation model\n * @type {Class}\n */\nexport default class extends think.model.base {\n  /**\n   * init\n   * @param  {String} name   []\n   * @param  {Object} config []\n   * @return {}        []\n   */\n  init(name = '', config = {}){\n    super.init(name, config);\n    /**\n     * @example\n     'profile': {\n        type: think.model.HAS_ONE, //relation type\n        model: 'profile', //model name\n        name: 'profile', //data name\n        key: 'id', \n        fKey: 'user_id', //forign key\n        field: 'id,name',\n        where: 'name=xx',\n        order: '',\n        limit: ''\n      }\n     */\n    if(this.relation === undefined){\n      this.relation = {};\n    }\n    this._relationName = true;\n  }\n  /**\n   * set relation\n   * @param {String} name []\n   */\n  setRelation(name, value){\n    //ignore undefined name\n    if(name === undefined){\n      return this;\n    }\n\n    //config relation data\n    if (think.isObject(name) || !think.isEmpty(value)) {\n      let obj = think.isObject(name) ? name : {[name]: value};\n      think.extend(this.relation, obj);\n      return this;\n    }\n\n    if(think.isBoolean(name)){\n      this._relationName = name;\n      return this;\n    }\n\n    //enable relation\n    if (think.isString(name)) {\n      name = name.split(/\\s*,\\s*/);\n    }\n\n    name = name || [];\n    //filter relation name\n    if(value === false){\n      let filterRelations = Object.keys(this.relation).filter(item => {\n        return name.indexOf(item) === -1;\n      });\n      name = filterRelations;\n    }\n\n    this._relationName = name;\n    return this;\n  }\n  /**\n   * after find\n   * @param  {Object} data []\n   * @return {Promise}      []\n   */\n  afterFind(data, options){\n    return this.getRelation(data, options);\n  }\n  /**\n   * after select\n   * @param  {Object} data []\n   * @return {}      []\n   */\n  afterSelect(data, options){\n    return this.getRelation(data, options);\n  }\n  /**\n   * get relation data\n   * @param  {}  data       []\n   * @param  Boolean isDataList \n   * @return {}\n   */\n  async getRelation(data, options = {}){\n    if (think.isEmpty(data) || think.isEmpty(this.relation) || think.isEmpty(this._relationName)) {\n      return data;\n    }\n    let pk = await this.getPk();\n    let promises = Object.keys(this.relation).map(key => {\n      //relation is disabled\n      if (this._relationName !== true && this._relationName.indexOf(key) === -1) {\n        return;\n      }\n      let item = this.relation[key];\n      if (!think.isObject(item)) {\n        item = {type: item};\n      }\n      //get relation model options\n      let opts = think.extend({\n        name: key,\n        type: think.model.HAS_ONE,\n        key: pk,\n        fKey: this.name + '_id',\n        relation: true\n      }, item);\n\n      //relation data is exist\n      let itemData = think.isArray(data) ? data[0] : data;\n      let relData = itemData[opts.name];\n      if(think.isArray(relData) || think.isObject(relData)){\n        return;\n      }\n\n      let modelOpts = think.extend({}, {\n        cache: options.cache\n      });\n      //remove cache key\n      if(modelOpts.cache && modelOpts.cache.key){\n        delete modelOpts.cache.key;\n      }\n\n      ['where', 'field', 'order', 'limit', 'page'].forEach(optItem => {\n        if(think.isFunction(item[optItem])){\n          modelOpts[optItem] = item[optItem](this);\n        }else{\n          modelOpts[optItem] = item[optItem];\n        }\n      });\n      //get relation model instance\n      let model = this.model(item.model || key).options(modelOpts);\n\n      //set relation to relate model\n      if(model.setRelation){\n        model.setRelation(opts.relation, false);\n      }\n\n      opts.model = model;\n      \n      switch(item.type){\n        case think.model.BELONG_TO:\n          // if(item.model) {\n          //   delete item.model;\n          // }\n          opts = think.extend(opts, {\n            key: opts.model.getModelName() + '_id',\n            fKey: 'id' \n          }, item);\n          opts.model = model; //get ref back\n          return this._getBelongsToRelation(data, opts, options);\n        case think.model.HAS_MANY:\n          return this._getHasManyRelation(data, opts, options);\n        case think.model.MANY_TO_MANY:\n          return this._getManyToManyRelation(data, opts, options);\n        default:\n          return this._getHasOneRelation(data, opts, options);\n      }\n    });\n    await Promise.all(promises);\n    return data;\n  }\n  /**\n   * has one\n   * @param  {Object} data    []\n   * @param  {Object} mapOpts []\n   * @return {Promise}         []\n   */\n  async _getHasOneRelation(data, mapOpts/*, options*/){\n    let where = this.parseRelationWhere(data, mapOpts);\n    // if (where === false) {\n    //   return {};\n    // }\n    let mapData = await mapOpts.model.where(where).select();\n    return this.parseRelationData(data, mapData, mapOpts);\n  }\n  /**\n   * belongs to\n   * @param  {Object} data    []\n   * @param  {Object} mapOpts []\n   * @return {Promise}         []\n   */\n  async _getBelongsToRelation(data, mapOpts/*, options*/){\n    let where = this.parseRelationWhere(data, mapOpts);\n    let mapData = await mapOpts.model.where(where).select();\n    return this.parseRelationData(data, mapData, mapOpts);\n  }\n  /**\n   * has many\n   * @param  {Object} data    []\n   * @param  {Object} mapOpts []\n   * @return {Promise}         []\n   */\n  async _getHasManyRelation(data, mapOpts/*, options*/){\n    let where = this.parseRelationWhere(data, mapOpts);\n    // if (where === false) {\n    //   return [];\n    // }\n    let mapData = await mapOpts.model.where(where).select();\n    return this.parseRelationData(data, mapData, mapOpts, true);\n  }\n  /**\n   * many to many\n   * @param  {Object} data    []\n   * @param  {Object} mapOpts []\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async _getManyToManyRelation(data, mapOpts, options){\n    let where = this.parseRelationWhere(data, mapOpts);\n    let sql = 'SELECT %s, a.%s FROM %s as a, %s as b %s AND a.%s=b.%s %s';\n    let field = this.db().parseField(mapOpts.field).split(',').map(item => `b.${item}`).join(',');\n    let pk = await mapOpts.model.getPk();\n\n    let table = mapOpts.rModel;\n    if(table){\n      if(this.tablePrefix && table.indexOf(this.tablePrefix) !== 0){\n        table = this.tablePrefix + table;\n      }\n    }else{\n     table = this.getRelationTableName(mapOpts.model);\n    }\n\n    let table1 = mapOpts.model.getTableName();\n    let where1 = this.db().parseWhere(where);\n    let rkey = mapOpts.rfKey || (mapOpts.model.getModelName() + '_id');\n    let where2 = mapOpts.where ? (' AND ' + this.db().parseWhere(mapOpts.where).trim().slice(6)) : '';\n    sql = this.parseSql(sql, field, mapOpts.fKey, table, table1, where1, rkey, pk, where2);\n    let mapData = await this.db().select(sql, options.cache);\n    return this.parseRelationData(data, mapData, mapOpts, true);\n  }\n  /**\n   * get relation table name\n   * @param  {Object} model []\n   * @return {}       []\n   */\n  getRelationTableName(model){\n    let table = [\n      this.tablePrefix,\n      this.tableName || this.name,\n      '_',\n      model.getModelName()\n    ].join('');\n    return table.toLowerCase();\n  }\n  /**\n   * get relation model\n   * @param  {} model []\n   * @return {}       []\n   */\n  getRelationModel(model){\n    let name = (this.tableName || this.name) + '_' + model.getModelName();\n    return this.model(name);\n  }\n  /**\n   * parese relation where\n   * @param  {Object} data    []\n   * @param  {Object} mapOpts []\n   * @return {}         []\n   */\n  parseRelationWhere(data, mapOpts){\n    if (think.isArray(data)) {\n      let keys = {};\n      data.forEach(item => {\n        keys[item[mapOpts.key]] = 1;\n      });\n      let value = Object.keys(keys);\n      return {\n        [mapOpts.fKey]: ['IN', value]\n      };\n    }\n    return {\n      [mapOpts.fKey]: data[mapOpts.key]\n    };\n  }\n  /**\n   * parse relation data\n   * @param  {Object}  data     []\n   * @param  {}  mapData  []\n   * @param  {}  mapOpts  []\n   * @param  {Boolean} isArrMap []\n   * @return {}           []\n   */\n  parseRelationData(data, mapData, mapOpts, isArrMap){\n    if (think.isArray(data)) {\n      if (isArrMap) {\n        data.forEach((item, i) => {\n          data[i][mapOpts.name] = [];\n        });\n      }\n      mapData.forEach(mapItem => {\n        data.forEach((item, i) => {\n          if (mapItem[mapOpts.fKey] !== item[mapOpts.key]) {\n            return;\n          }\n          if (isArrMap) {\n            data[i][mapOpts.name].push(mapItem);\n          }else{\n            data[i][mapOpts.name] = mapItem;\n          }\n        });\n      });\n    }else{\n      data[mapOpts.name] = isArrMap ? mapData : (mapData[0] || {});\n    }\n    return data;\n  }\n  /**\n   * after add\n   * @param  {} data          []\n   * @param  {} parsedOptions []\n   * @return {}               []\n   */\n  afterAdd(data, options){\n    return this.postRelation('ADD', data, options);\n  }\n  /**\n   * after delete\n   * @param  {} data          []\n   * @param  {} parsedOptions []\n   * @return {}               []\n   */\n  afterDelete(options = {}){\n    return this.postRelation('DELETE', options.where, options);\n  }\n  /**\n   * after update\n   * @param  {} data          []\n   * @param  {} parsedOptions []\n   * @return {}               []\n   */\n  afterUpdate(data, options){\n    return this.postRelation('UPDATE', data, options);\n  }\n  /**\n   * post relation\n   * @param  {} postType      []\n   * @param  {} data          []\n   * @param  {} parsedOptions []\n   * @return {}               []\n   */\n  async postRelation(postType, data/*, parsedOptions*/){\n    if (think.isEmpty(data) || think.isEmpty(this.relation) || think.isEmpty(this._relationName)) {\n      return data;\n    }\n    let pk = await this.getPk();\n    let promises = Object.keys(this.relation).map(key => {\n      let item = this.relation[key];\n      if (!think.isObject(item)) {\n        item = {type: item};\n      }\n      let opts = think.extend({\n        type: think.model.HAS_ONE,\n        postType: postType,\n        name: key,\n        key: pk,\n        fKey: this.name + '_id'\n      }, item);\n      if (this._relationName !== true && this._relationName.indexOf(opts.name) === -1) {\n        return;\n      }\n      if(postType === 'DELETE'){\n        opts.data = data;\n      }else{\n        let mapData = data[opts.name];\n        if (think.isEmpty(mapData)) {\n          return;\n        }\n        opts.data = mapData;\n      }\n      opts.model = this.model(item.model || key).where(item.where);\n      switch(item.type){\n        case think.model.BELONG_TO:\n          return this._postBelongsToRelation(data, opts);\n        case think.model.HAS_MANY:\n          return this._postHasManyRelation(data, opts);\n        case think.model.MANY_TO_MANY:\n          return this._postManyToManyRelation(data, opts);\n        default:\n          return this._postHasOneRelation(data, opts);\n      }\n    });\n    await Promise.all(promises);\n    return data;\n  }\n  /**\n   * has one post\n   * @param  {} data          []\n   * @param  {} value         []\n   * @param  {} mapOptions    []\n   * @param  {} parsedOptions []\n   * @return {}               []\n   */\n  _postHasOneRelation(data, mapOpts){\n    let where;\n    switch(mapOpts.postType){\n      case 'ADD':\n        mapOpts.data[mapOpts.fKey] = data[mapOpts.key];\n        return mapOpts.model.add(mapOpts.data);\n      case 'DELETE':\n        where = {[mapOpts.fKey]: data[mapOpts.key]};\n        return mapOpts.model.where(where).delete();\n      case 'UPDATE':\n        where = {[mapOpts.fKey]: data[mapOpts.key]};\n        return mapOpts.model.where(where).update(mapOpts.data);\n    }\n  }\n  /**\n   * belongs to\n   * @param  {} data []\n   * @return {}      []\n   */\n  _postBelongsToRelation(data){\n    return data;\n  }\n  /**\n   * has many\n   * @param  {} data          []\n   * @param  {} value         []\n   * @param  {} mapOptions    []\n   * @param  {} parsedOptions []\n   * @return {}               []\n   */\n  _postHasManyRelation(data, mapOpts){\n    let mapData = mapOpts.data;\n    let model = mapOpts.model;\n    if (!think.isArray(mapData)) {\n      mapData = [mapData];\n    }\n    switch(mapOpts.postType){\n      case 'ADD':\n        mapData = mapData.map(item => {\n          item[mapOpts.fKey] = data[mapOpts.key];\n          return item;\n        });\n        return model.addMany(mapData);\n      case 'UPDATE':\n        return model.getSchema().then(() => {\n          let pk = model.getPk();\n          let promises = mapData.map(item => {\n            if (item[pk]) {\n              return model.update(item);\n            }else{\n              item[mapOpts.fKey] = data[mapOpts.key];\n              //ignore error when add data\n              return model.add(item).catch(() => {});\n            }\n          });\n          return Promise.all(promises);\n        });\n      case 'DELETE':\n        let where = {[mapOpts.fKey]: data[mapOpts.key]};\n        return model.where(where).delete();\n    }\n  }\n  /**\n   * many to many post\n   * @param  Object data          []\n   * @param  object value         []\n   * @param  {} mapOptions    []\n   * @param  {} parsedOptions []\n   * @return {}               []\n   */\n  async _postManyToManyRelation(data, mapOpts){\n    let model = mapOpts.model;\n    await model.getSchema();\n    let rfKey = mapOpts.rfKey || (model.getModelName().toLowerCase() + '_id');\n    let relationModel = mapOpts.rModel ? this.model(mapOpts.rModel) : this.getRelationModel(model);\n\n    let type = mapOpts.postType;\n    if (type === 'DELETE' || type === 'UPDATE') {\n      let where = {[mapOpts.fKey]: data[mapOpts.key]};\n      await relationModel.where(where).delete(); \n    }\n\n    if (type === 'ADD' || type === 'UPDATE') {\n      let mapData = mapOpts.data;\n      if (!think.isArray(mapData)) {\n        mapData = think.isString(mapData) ? mapData.split(',') : [mapData];\n      }\n      let firstItem = mapData[0];\n      if (think.isNumberString(firstItem) || (think.isObject(firstItem) && (rfKey in firstItem))) {\n        let postData = mapData.map(item => {\n          return {[mapOpts.fKey]: data[mapOpts.key], [rfKey]: item[rfKey] || item};\n        });\n        await relationModel.addMany(postData);\n      }else{ \n        let unqiueField = await model.getUniqueField();\n        if (!unqiueField) {\n          return think.reject(new Error('table `' + model.getTableName() + '` has no unqiue field'));\n        }\n        let ids = await this._getRalationAddIds(mapData, model, unqiueField);\n        let postData = ids.map(id => {\n          return {[mapOpts.fKey]: data[mapOpts.key], [rfKey]: id};\n        });\n        await relationModel.addMany(postData);\n      }\n    }\n  }\n  /**\n   * insert data, add ids\n   * @param  {Array} dataList    []\n   * @param  {Object} model       []\n   * @param  {String} unqiueField []\n   * @return {Promise}             []\n   */\n  async _getRalationAddIds(dataList, model, unqiueField){\n    let ids = [];\n    let pk = await model.getPk();\n    let promises = dataList.map(item => {\n      if (!think.isObject(item)) {\n        item = {[unqiueField]: item};\n      }\n      let value = item[unqiueField];\n      let where = {[unqiueField]: value};\n      return model.where(where).field(pk).find().then(data => {\n        if (think.isEmpty(data)) {\n          return model.add(item).then(insertId => {\n            ids.push(insertId);\n          });\n        }else{\n          ids.push(data[pk]);\n        }\n      });\n    });\n    await Promise.all(promises);\n    return ids;\n  }\n}\n"]}