{"version":3,"sources":["../../src/core/think_validate.js"],"names":["_getValidateErrorMsg","type","name","value","args","msgs","key","keyWithName","msg","think","locale","replace","join","_getValidateRuleFnAndArgs","rules","fn","isFunction","Error","isBoolean","isArray","parseArgs","_getRuleValues","ret","_toBoolean","indexOf","_parseValue","item","int","parseInt","float","parseFloat","boolean","_getItemValue","values","parse","itemValue","trim","_default","default","isTrueEmpty","call","array","isString","JSON","e","split","object","map","it","Validate","callback","exec","vtype","flag","some","result","ivalue","rule","forEach","pos","substr","Function"],"mappings":"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","file":"think_validate.js","sourcesContent":["'use strict';\n\nimport Validator from '../util/validator.js';\n\n/**\n * validate data\n * {\n *   name: {\n *     value: 'test',\n *     required: true,\n *     length: [4, 20],\n *     email: true\n *   },\n *   pwd: {\n *     value: '12345678',\n *     required: true,\n *     length: [6, 20]\n *   }\n *   confirm_pwd: {\n *     value: '12345678',\n *     required: true,\n *     equals: 'pwd'\n *   }\n * }\n * @param  {String | Object}   name     []\n * @param  {Function} callback []\n * @return {}            []\n */\n\n//get error message\nlet _getValidateErrorMsg = (type, name, value, args, msgs) => {\n  let key = `validate_${type}`;\n  let keyWithName = `${key}_${name}`;\n  let msg = msgs[keyWithName];\n  if(!msg && think.locale(keyWithName) !== keyWithName){\n    msg = think.locale(keyWithName);\n  }\n  msg = msg || msgs[key];\n  if(!msg && think.locale(key) !== key){\n    msg = think.locale(key);\n  }\n  msg = msg || think.locale('PARAMS_NOT_VALID');\n  return msg.replace('{name}', name).replace('{value}', value).replace('{args}', args.join(','));\n};\n\nlet _getValidateRuleFnAndArgs = (type, args, rules) => {\n  let fn = Validator[type];\n  if (!think.isFunction(fn)) {\n    throw new Error(think.locale('CONFIG_NOT_FUNCTION', `${type} type`));\n  }\n  if(think.isBoolean(args)){\n    args = [];\n  }else if(!think.isArray(args)){\n    args = [args];\n  }\n  let parseArgs = Validator[`_${type}`];\n  //parse args\n  if(think.isFunction(parseArgs)){\n    args = parseArgs(args, rules);\n  }\n  return {fn, args};\n};\n\n/**\n * get all rule values, for default function to get value\n * @param  {Object} rules []\n * @return {Object}       []\n */\nlet _getRuleValues = rules => {\n  let ret = {};\n  for(let name in rules){\n    ret[name] = rules[name].value;\n  }\n  return ret;\n};\n\n/**\n * to boolean\n * @param  {Mixed} value []\n * @return {Boolean}       []\n */\nlet _toBoolean = value => {\n  return ['yes', 'on', '1', 'true', true].indexOf(value) > -1;\n};\n\n/**\n * parse value\n * @param  {Mixed} value []\n * @param  {Object} item  []\n * @return {Mixed}       []\n */\nlet _parseValue = (value, item) => {\n  if(item.int || item.type === 'int'){\n    return parseInt(value);\n  }else if(item.float || item.type === 'float'){\n    return parseFloat(value);\n  }else if(item.boolean || item.type === 'boolean'){\n    return _toBoolean(value);\n  }\n  return value;\n};\n/**\n * get item value\n * @param  {Object} item   []\n * @param  {Object} values []\n * @return {Mixed}        []\n */\nlet _getItemValue = (item, values, parse) => {\n  //get item value\n  //avoid default is undefined, but check type is string\n  let itemValue = item.value;\n  //trim value\n  if(item.trim && itemValue && itemValue.trim){\n    itemValue = itemValue.trim();\n  }\n  let _default = item.default;\n  if(!itemValue && !think.isTrueEmpty(_default)){\n    itemValue = item.default;\n  }\n  if(think.isFunction(itemValue)){\n    itemValue = itemValue.call(values);\n  }\n\n  //make data to array when type is array\n  if(item.value && item.array && !think.isArray(item.value)){\n    if(think.isString(itemValue)){\n      try{\n        itemValue = JSON.parse(itemValue);\n      }catch(e){\n        itemValue = itemValue.split(/\\s*,\\s*/);\n      }\n    }else{\n      itemValue = [itemValue];\n    }\n  }\n  //make data to object when type is object\n  else if(item.value && item.object && think.isString(itemValue)){\n    try{\n      itemValue = JSON.parse(itemValue);\n    }catch(e){}\n  }\n  else if(item.boolean){\n    itemValue = _toBoolean(itemValue);\n  }\n\n  //parse value\n  if(parse){\n    if(item.array){\n      itemValue = itemValue.map(it => {\n        return _parseValue(it, item);\n      });\n    }else{\n      itemValue = _parseValue(itemValue, item);\n    }\n  }\n\n  return itemValue;\n};\n\n\nlet Validate = (name, callback) => {\n  // register validate callback\n  if (think.isString(name)) {\n    // think.validate('test', function(){})\n    if (think.isFunction(callback)) {\n      Validator[name] = callback;\n      return;\n    }\n    // get validator callback\n    return Validator[name];\n  }\n  return Validate.exec(name, callback);\n};\n\n/**\n * exec validate\n * @param  {Object} rules []\n * @param  {Object} msgs  []\n * @return {Object}       []\n */\nValidate.exec = (rules, msgs = {}) => {\n  let ret = {};\n  let values = _getRuleValues(rules);\n\n  for(let name in rules){\n    let item = rules[name];\n    let itemValue = _getItemValue(item, values);\n    for(let vtype in item){\n      if(vtype === 'value' || vtype === 'default' || vtype === 'trim'){\n        continue;\n      }\n      //if has array rule, then foreach check value for every rule\n      if(item.array && vtype !== 'array' && think.isArray(itemValue)){\n        let flag = itemValue.some(ivalue => {\n          let {fn, args} = _getValidateRuleFnAndArgs(vtype, item[vtype], rules);\n          let result = fn(ivalue, ...args);\n          if(!result){\n            let msg = _getValidateErrorMsg(vtype, name, ivalue, args, msgs);\n            ret[name] = msg;\n            return true;\n          }\n        });\n        if(flag){\n          break;\n        }\n      }else{\n        let {fn, args} = _getValidateRuleFnAndArgs(vtype, item[vtype], rules);\n        let result = fn(itemValue, ...args);\n        if(!result){\n          let msg = _getValidateErrorMsg(vtype, name, itemValue, args, msgs);\n          ret[name] = msg;\n          break;\n        }\n      }\n    }\n  }\n  return ret;\n};\n\n/**\n * get new values for rules\n * @param  {Object} rules []\n * @return {Object}       []\n */\nValidate.values = rules => {\n  let ret = {};\n  let values = _getRuleValues(rules);\n  for(let name in rules){\n    let itemValue = _getItemValue(rules[name], values, true);\n    ret[name] = itemValue;\n  }\n  return ret;\n};\n\n/**\n * parse string rule to object\n * @param  {String} rule []\n * @return {Object}      []\n */\nValidate.parse = rule => {\n  let rules = rule.split('|');\n  let ret = {};\n  rules.forEach(item => {\n    item = item.trim();\n    if(!item){\n      return;\n    }\n    let pos = item.indexOf(':');\n    if(pos > -1){\n      let name = item.substr(0, pos);\n      let args = item.substr(pos + 1).trim();\n      if(args[0] === '{' || args[0] === '['){\n        let value = (new Function('', `return ${args}`))();\n        args = name === 'default' ? value : [value];\n      }else if(name !== 'default'){\n        args = args.split(/\\s*,\\s*/);\n      }\n      ret[name] = args;\n    }else{\n      ret[item] = true;\n    }\n  });\n  return ret;\n};\n\nexport default Validate;"]}