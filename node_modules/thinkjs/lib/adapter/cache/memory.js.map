{"version":3,"sources":["../../../src/adapter/cache/memory.js"],"names":["BaseStore","think","adapter","init","options","parseConfig","config","timeout","store","type","thinkCache","MEMORY","gcType","gc","get","name","then","data","expire","Date","now","delete","clone","set","value","list","key","item","base"],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AAIA,IAAIA,YAAYC,MAAMC,OAAN,CAAc,OAAd,EAAuB,QAAvB,CAAhB;AACA;;;;;;;;;;;;AAIE;;;;;mBAKAC,I,iBAAKC,O,EAAQ;;AAEXA,cAAUH,MAAMI,WAAN,CAAkBJ,MAAMK,MAAN,CAAa,OAAb,CAAlB,EAAyCF,OAAzC,CAAV;;AAEA,SAAKG,OAAL,GAAeH,QAAQG,OAAvB;;AAEA,SAAKC,KAAL,GAAa,IAAIR,SAAJ,CAAc;AACzBS,YAAMC,WAAWC;AADQ,KAAd,CAAb;;AAIA;AACA,SAAKC,MAAL,GAAc,cAAd;AACAX,UAAMY,EAAN,CAAS,IAAT;AACD,G;AACD;;;;;;;mBAKAC,G,gBAAIC,I,EAAK;AAAA;;AACP,WAAO,KAAKP,KAAL,CAAWM,GAAX,CAAeC,IAAf,EAAqBC,IAArB,CAA0B,gBAAQ;AACvC,UAAG,CAACC,IAAJ,EAAS;AACP;AACD;AACD;AACA,UAAGA,KAAKC,MAAL,IAAeC,KAAKC,GAAL,KAAaH,KAAKC,MAApC,EAA2C;AACzC,eAAO,OAAKV,KAAL,CAAWa,MAAX,CAAkBN,IAAlB,CAAP;AACD;AACD,aAAOd,MAAMqB,KAAN,CAAYL,KAAKA,IAAjB,CAAP;AACD,KATM,CAAP;AAUD,G;AACD;;;;;;;;;mBAOAM,G,gBAAIR,I,EAAMS,K,EAA8B;AAAA,QAAvBjB,OAAuB,uEAAb,KAAKA,OAAQ;;AACtCiB,YAAQvB,MAAMqB,KAAN,CAAYE,KAAZ,CAAR;AACA,QAAIP,OAAO;AACTC,cAAQX,UAAU,CAAV,GAAeY,KAAKC,GAAL,KAAab,UAAU,IAAtC,GAA8C,IAD7C;AAETA,sBAFS;AAGTU,YAAMO;AAHG,KAAX;AAKA,WAAO,KAAKhB,KAAL,CAAWe,GAAX,CAAeR,IAAf,EAAqBE,IAArB,CAAP;AACD,G;AACD;;;;;;;mBAKAI,M,oBAAON,I,EAAK;AACV,WAAO,KAAKP,KAAL,CAAWa,MAAX,CAAkBN,IAAlB,CAAP;AACD,G;AACD;;;;;;;mBAKAF,E,iBAAI;AACF,QAAIO,MAAMD,KAAKC,GAAL,EAAV;AACA,WAAO,KAAKZ,KAAL,CAAWiB,IAAX,GAAkBT,IAAlB,CAAuB,gBAAQ;AACpC,WAAI,IAAIU,GAAR,IAAeD,IAAf,EAAoB;AAClB,YAAIE,OAAOF,KAAKC,GAAL,CAAX;AACA,YAAGC,QAAQA,KAAKT,MAAb,IAAuBE,MAAMO,KAAKT,MAArC,EAA4C;AAC1C,iBAAOO,KAAKC,GAAL,CAAP;AACD;AACF;AACF,KAPM,CAAP;AAQD,G;;;EA5E0BzB,MAAMC,OAAN,CAAc0B,I","file":"memory.js","sourcesContent":["'use strict';\n/**\n * base store\n * @type {Class}\n */\nlet BaseStore = think.adapter('store', 'memory');\n/**\n * memory cache\n */\nexport default class extends think.adapter.base {\n  /**\n   * init\n   * @param  {Object} options []\n   * @return {}         []\n   */\n  init(options){\n\n    options = think.parseConfig(think.config('cache'), options);\n\n    this.timeout = options.timeout;\n\n    this.store = new BaseStore({\n      type: thinkCache.MEMORY\n    });\n    \n    //set gc type & start gc\n    this.gcType = 'cache_memory';\n    think.gc(this);\n  }\n  /**\n   * get session data\n   * @param  {String} name []\n   * @return {Promise}      []\n   */\n  get(name){\n    return this.store.get(name).then(data => {\n      if(!data){\n        return;\n      }\n      //data is expire\n      if(data.expire && Date.now() > data.expire){\n        return this.store.delete(name);\n      }\n      return think.clone(data.data);\n    });\n  }\n  /**\n   * set session data\n   * @param {String} name    []\n   * @param {Mixed} value   []\n   * @param {Number} timeout []\n   * @return {Promise} []\n   */\n  set(name, value, timeout = this.timeout){\n    value = think.clone(value);\n    let data = {\n      expire: timeout > 0 ? (Date.now() + timeout * 1000) : null,\n      timeout,\n      data: value\n    };\n    return this.store.set(name, data);\n  }\n  /**\n   * delete session data\n   * @param  {String} name []\n   * @return {Promise}      []\n   */\n  delete(name){\n    return this.store.delete(name);\n  }\n  /**\n   * gc\n   * is internal method\n   * @return {} []\n   */\n  gc(){\n    let now = Date.now();\n    return this.store.list().then(list => {\n      for(let key in list){\n        let item = list[key];\n        if(item && item.expire && now > item.expire){\n          delete list[key];\n        }\n      }\n    });\n  }\n}\n"]}