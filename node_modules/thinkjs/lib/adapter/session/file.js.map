{"version":3,"sources":["../../../src/adapter/session/file.js"],"names":["FileStore","think","adapter","init","options","parseConfig","config","timeout","cookie","newCookie","path","normalize","tmpdir","sep","path_depth","store","gcType","gc","data","dataEmpty","getFilepath","name","dir","slice","split","join","getInitData","filepath","await","get","catch","JSON","parse","Date","now","expire","delete","getData","isEmpty","then","set","value","flush","saveData","list","files","forEach","file","content","readFileSync","unlink","e","base"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;;;AAEA;;;;AAIA,IAAIA,YAAYC,MAAMC,OAAN,CAAc,OAAd,EAAuB,MAAvB,CAAhB;;AAEA;;;;;;;;;;;;AAIE;;;;;mBAKAC,I,iBAAKC,O,EAAQ;;AAEXA,cAAUH,MAAMI,WAAN,CAAkBJ,MAAMK,MAAN,CAAa,SAAb,CAAlB,EAA2CF,OAA3C,CAAV;;AAEA,SAAKG,OAAL,GAAeH,QAAQG,OAAvB;AACA,SAAKC,MAAL,GAAcJ,QAAQI,MAAtB;AACA,SAAKC,SAAL,GAAiBL,QAAQK,SAAzB;AACA,SAAKC,IAAL,GAAYN,QAAQM,IAAR,IAAgB,eAAKC,SAAL,CAAe,aAAGC,MAAH,KAAc,eAAKC,GAAnB,GAAyB,SAAxC,CAA5B;AACA,SAAKC,UAAL,GAAkBV,QAAQU,UAAR,IAAsB,CAAxC;;AAEA,SAAKC,KAAL,GAAa,IAAIf,SAAJ,CAAc;AACzBU,YAAM,KAAKA;AADc,KAAd,CAAb;;AAIA,SAAKM,MAAL,GAAc,KAAKN,IAAnB;AACAT,UAAMgB,EAAN,CAAS,IAAT;;AAEA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACD,G;AACD;;;;;;mBAIAC,W,0BAAa;AACX,QAAIC,OAAO,KAAKb,MAAhB;AACA,QAAIc,MAAMD,KAAKE,KAAL,CAAW,CAAX,EAAc,KAAKT,UAAnB,EAA+BU,KAA/B,CAAqC,EAArC,EAAyCC,IAAzC,CAA8C,eAAKZ,GAAnD,CAAV;AACA,gBAAUS,GAAV,GAAgB,eAAKT,GAArB,GAA2BQ,IAA3B;AACD,G;AACD;;;;;;mBAIMK,W;;;;;;;;;mBAED,KAAKjB,S;;;;;+CACC,E;;;AAELkB,sB,GAAW,KAAKP,WAAL,E;AACf;;;qBACiBnB,MAAM2B,KAAN,cAAuB,KAAKpB,MAA5B,EAAsC,YAAM;AAC3D,uBAAO,OAAKO,KAAL,CAAWc,GAAX,CAAeF,QAAf,EAAyBG,KAAzB,CAA+B,YAAM,CAAE,CAAvC,CAAP;AACD,eAFgB,C;;;AAAbZ,kB;;kBAGAA,I;;;;;+CACK,E;;;;;AAGPA,qBAAOa,KAAKC,KAAL,CAAWd,IAAX,CAAP;;;;;;;+CAEO,E;;;oBAENe,KAAKC,GAAL,KAAahB,KAAKiB,M;;;;;;qBACb,KAAKpB,KAAL,CAAWqB,MAAX,CAAkBT,QAAlB,C;;;;;;;+CAECT,KAAKA,IAAL,IAAa,E;;;+CAEf,E;;;;;;;;;;;;;;;;AAET;;;;;;mBAIMmB,O;;;;;;;mBACD,KAAKnB,I;;;;;gDACC,KAAKA,I;;;;qBAEG,KAAKQ,WAAL,E;;;AAAbR,kB;;AACJ,kBAAGjB,MAAMqC,OAAN,CAAcpB,IAAd,CAAH,EAAuB;AACrB,qBAAKC,SAAL,GAAiB,IAAjB;AACD;AACD,mBAAKD,IAAL,GAAYA,IAAZ;gDACO,KAAKA,I;;;;;;;;;;;;;;;;AAEd;;;;;;;mBAKAW,G,gBAAIR,I,EAAK;AAAA;;AACP,WAAO,KAAKgB,OAAL,GAAeE,IAAf,CAAoB,YAAM;AAC/B,aAAOlB,OAAO,OAAKH,IAAL,CAAUG,IAAV,CAAP,GAAyB,OAAKH,IAArC;AACD,KAFM,CAAP;AAGD,G;AACD;;;;;;;;mBAMAsB,G,gBAAInB,I,EAAMoB,K,EAA8B;AAAA;;AAAA,QAAvBlC,OAAuB,uEAAb,KAAKA,OAAQ;;AACtC,SAAKA,OAAL,GAAeA,OAAf;AACA,WAAO,KAAK8B,OAAL,GAAeE,IAAf,CAAoB,YAAM;AAC/B,aAAKrB,IAAL,CAAUG,IAAV,IAAkBoB,KAAlB;AACD,KAFM,CAAP;AAGD,G;AACD;;;;;;;mBAKAL,M,oBAAOf,I,EAAK;AAAA;;AACV,WAAO,KAAKgB,OAAL,GAAeE,IAAf,CAAoB,YAAM;AAC/B,UAAGlB,IAAH,EAAQ;AACN,eAAO,OAAKH,IAAL,CAAUG,IAAV,CAAP;AACD,OAFD,MAEK;AACH,eAAKH,IAAL,GAAY,EAAZ;AACD;AACF,KANM,CAAP;AAOD,G;AACD;;;;;;mBAIMwB,K;;;;;;;;qBACa,KAAKL,OAAL,E;;;AAAbnB,kB;;oBAED,KAAKC,SAAL,IAAkBlB,MAAMqC,OAAN,CAAcpB,IAAd,C;;;;;;;;AAGjByB,sB,GAAW;AACbzB,sBAAM,KAAKA,IADE;AAEbiB,wBAAQF,KAAKC,GAAL,KAAa,KAAK3B,OAAL,GAAe,IAFvB;AAGbA,yBAAS,KAAKA;AAHD,e;AAKXoB,sB,GAAW,KAAKP,WAAL,E;gDACR,KAAKL,KAAL,CAAWyB,GAAX,CAAeb,QAAf,EAAyB,yBAAegB,QAAf,CAAzB,C;;;;;;;;;;;;;;;;AAET;;;;;;mBAIA1B,E,iBAAI;AAAA;;AACF,QAAIiB,MAAMD,KAAKC,GAAL,EAAV;AACA,WAAO,KAAKnB,KAAL,CAAW6B,IAAX,GAAkBL,IAAlB,CAAuB,iBAAS;AACrCM,YAAMC,OAAN,CAAc,gBAAQ;AACpB,YAAInB,gBAAc,OAAKjB,IAAnB,GAA0B,eAAKG,GAA/B,GAAqCkC,IAAzC;AACA,YAAIC,UAAU,aAAGC,YAAH,CAAgBtB,QAAhB,EAA0B,MAA1B,CAAd;AACA,YAAG;AACD,cAAIT,OAAOa,KAAKC,KAAL,CAAWgB,OAAX,CAAX;AACA,cAAGd,MAAMhB,KAAKiB,MAAd,EAAqB;AACnB,yBAAGe,MAAH,CAAUvB,QAAV,EAAoB,YAAM,CAAE,CAA5B;AACD;AACF,SALD,CAKC,OAAMwB,CAAN,EAAQ;AACP,uBAAGD,MAAH,CAAUvB,QAAV,EAAoB,YAAM,CAAE,CAA5B;AACD;AACF,OAXD;AAYD,KAbM,CAAP;AAcD,G;;;EAzJ0B1B,MAAMC,OAAN,CAAckD,I","file":"file.js","sourcesContent":["'use strict';\n\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\n/**\n * file store\n * @type {Class}\n */\nlet FileStore = think.adapter('store', 'file');\n\n/**\n * file session\n */\nexport default class extends think.adapter.base {\n  /**\n   * init\n   * @param  {Object} options []\n   * @return {}         []\n   */\n  init(options){\n    \n    options = think.parseConfig(think.config('session'), options);\n\n    this.timeout = options.timeout;\n    this.cookie = options.cookie;\n    this.newCookie = options.newCookie;\n    this.path = options.path || path.normalize(os.tmpdir() + path.sep + 'thinkjs');\n    this.path_depth = options.path_depth || 1;\n\n    this.store = new FileStore({\n      path: this.path\n    });\n\n    this.gcType = this.path;\n    think.gc(this);\n\n    this.data = null;\n    this.dataEmpty = false;\n  }\n  /**\n   * get stored file path\n   * @return {String} []\n   */\n  getFilepath(){\n    let name = this.cookie;\n    let dir = name.slice(0, this.path_depth).split('').join(path.sep);\n    return `${dir}${path.sep}${name}.json`;\n  }\n  /**\n   * get init data\n   * @return {} []\n   */\n  async getInitData(){\n    //when session cookie is not exist, return direct\n    if(this.newCookie){\n      return {};\n    }\n    let filepath = this.getFilepath();\n    //ignore error\n    let data = await think.await(`session_${this.cookie}`, () => {\n      return this.store.get(filepath).catch(() => {});\n    });\n    if(!data){\n      return {};\n    }\n    try{\n      data = JSON.parse(data);\n    }catch(e){\n      return {};\n    }\n    if(Date.now() > data.expire){\n      await this.store.delete(filepath);\n    }else{\n      return data.data || {};\n    }\n    return {};\n  }\n  /**\n   * get session data\n   * @return {Promise} []\n   */\n  async getData(){\n    if(this.data){\n      return this.data;\n    }\n    let data = await this.getInitData();\n    if(think.isEmpty(data)){\n      this.dataEmpty = true;\n    }\n    this.data = data;\n    return this.data;\n  }\n  /**\n   * get data\n   * @param  {String} name []\n   * @return {Promise}      []\n   */\n  get(name){\n    return this.getData().then(() => {\n      return name ? this.data[name] : this.data;\n    });\n  }\n  /**\n   * set data\n   * @param {String} name    []\n   * @param {Mixed} value   []\n   * @param {Number} timeout []\n   */\n  set(name, value, timeout = this.timeout){\n    this.timeout = timeout;\n    return this.getData().then(() => {\n      this.data[name] = value;\n    });\n  }\n  /**\n   * delete data\n   * @param  {String} name []\n   * @return {Promise}      []\n   */\n  delete(name){\n    return this.getData().then(() => {\n      if(name){\n        delete this.data[name];\n      }else{\n        this.data = {};\n      }\n    });\n  }\n  /**\n   * flush data to file\n   * @return {Promise} []\n   */\n  async flush(){\n    let data = await this.getData();\n    //if data not changed and initial data is empty, then ignore it\n    if(this.dataEmpty && think.isEmpty(data)){\n      return;\n    }\n    let saveData = {\n      data: this.data,\n      expire: Date.now() + this.timeout * 1000,\n      timeout: this.timeout\n    };\n    let filepath = this.getFilepath();\n    return this.store.set(filepath, JSON.stringify(saveData));\n  }\n  /**\n   * gc\n   * @return {} []\n   */\n  gc(){\n    let now = Date.now();\n    return this.store.list().then(files => {\n      files.forEach(file => {\n        let filepath = `${this.path}${path.sep}${file}`;\n        let content = fs.readFileSync(filepath, 'utf8');\n        try{\n          let data = JSON.parse(content);\n          if(now > data.expire){\n            fs.unlink(filepath, () => {});\n          }\n        }catch(e){\n          fs.unlink(filepath, () => {});\n        }\n      });\n    });\n  }\n}"]}