{"version":3,"sources":["../../../src/adapter/db/_parse_mongo.js"],"names":["init","comparison","parseField","field","reverse","think","isString","split","isArray","result","forEach","item","key","parseLimit","limit","isNumber","skip","limitNum","parseOrder","order","$natural","type","toLowerCase","trim","parseGroup","group","isEmpty","parseWhere","where","map","isObject","value","validator","require","mongoId","ObjectID","parseDistinct","distinct","base"],"mappings":"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","file":"_parse_mongo.js","sourcesContent":["'use strict';\n\nexport default class extends think.base {\n  /**\n   * init\n   * @return {} []\n   */\n  init(){\n    this.comparison = {\n      'EQ': '$eq',\n      '=': '$eq',\n      'NEQ': '$ne',\n      '!=': '$ne',\n      '<>': '$ne',\n      'GT': '$gt',\n      '>': '$gt',\n      'EGT': '$gte',\n      '>=': '$gte',\n      'LT': '$lt',\n      '<': '$lt',\n      'ELT': '$lte',\n      '<=': '$lte',\n      'OR': '$or',\n      'IN': '$in',\n      'NOTIN': '$nin'\n    };\n  }\n  /**\n   * parse field\n   * @param  {String} field   []\n   * @param  {Boolean} reverse []\n   * @return {Object}         []\n   */\n  parseField(field, reverse){\n    if(!field){\n      return {};\n    }\n    if(think.isString(field)){\n      field = field.split(/\\s*,\\s*/);\n    }\n    if(think.isArray(field)){\n      let result = {};\n      field.forEach(item => {\n        result[item] = reverse ? 0 : 1;\n      });\n      return result;\n    }\n    if(reverse){\n      for(let key in field){\n        field[key] = 0;\n      }\n    }\n    return field;\n  }\n  /**\n   * parse limit\n   * @param  {Object} collection []\n   * @param  {Array} limit      []\n   * @return {Object}            []\n   */\n  parseLimit(limit){\n    if(!limit){\n      return [];\n    }\n    if(think.isNumber(limit)){\n      return [0, limit];\n    }\n    if(think.isString(limit)){\n      limit = limit.split(/\\s*,\\s*/);\n    }\n    let skip = limit[0] | 0;\n    let limitNum = limit[1] | 0;\n    if(limitNum){\n      return [skip, limitNum];\n    }\n    return [0, skip];\n  }\n  /**\n   * parse order\n   * @param  {String} order []\n   * @return {Object}       []\n   */\n  parseOrder(order){\n    if(!order){\n      return {};\n    }\n    if(order === true || order === 'natural'){\n      return {\n        $natural: 1\n      };\n    }\n    if(think.isString(order)){\n      order = order.split(/\\s*,\\s*/);\n      let result = {};\n      order.forEach(item => {\n        item = item.split(' ');\n        let type = (item[1] || '').toLowerCase();\n        result[item[0].trim()] = type === 'desc' ? -1 : 1;\n      });\n      return result;\n    }\n    for(let key in order){\n      if(order[key] === false || order[key] === 0){\n        order[key] = -1;\n      }else if(order[key] !== -1){\n        order[key] = 1;\n      }\n    }\n    return order;\n  }\n  /**\n   * parse group\n   * @param  {String} group []\n   * @return {Object}       []\n   */\n  parseGroup(group){\n    if (think.isEmpty(group)) {\n      return '';\n    }\n    if (think.isString(group)) {\n      group = group.split(/\\s*,\\s*/);\n    }\n    return group;\n  }\n  /**\n   * parse where\n   * http://docs.mongodb.org/manual/reference/operator/query/\n   * @param  {Object} where []\n   * @return {Object}       []\n   */\n  parseWhere(where){\n\n    if(think.isArray(where)){\n      return where.map(item => {\n        return this.parseWhere(item);\n      });\n    }\n    \n    if(think.isObject(where)){\n      let result = {};\n      for(let key in where){\n        let value = where[key];\n        if(key === '_id' && think.isString(value)){\n          let validator = think.require('validator');\n          if(validator.mongoId(value)){\n            let {ObjectID} = think.require('mongodb');\n            result[key] = ObjectID(value);\n            continue;\n          }\n        }\n        key = this.comparison[key] || key;\n        if(think.isObject(value) || think.isArray(value)){\n          value = this.parseWhere(value);\n        }\n        result[key] = value;\n      }\n      return result;\n    }\n    return where || {};\n  }\n  /**\n   * parse distinct\n   * @param  {String} distinct []\n   * @return {String}          []\n   */\n  parseDistinct(distinct){\n    return distinct;\n  }\n}"]}