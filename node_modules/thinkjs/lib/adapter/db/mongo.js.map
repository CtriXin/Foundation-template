{"version":3,"sources":["../../../src/adapter/db/mongo.js"],"names":["MongoSocket","think","adapter","init","config","lastInsertId","_socket","socket","getInstance","thinkCache","DB","collection","table","instance","getConnection","then","db","getLastInsertId","add","data","options","insert","result","_id","toString","addMany","dataList","insertedIds","map","item","limit","parseLimit","skip","group","parseGroup","length","forEach","select","where","parseWhere","distinct","parseDistinct","find","parseField","field","sort","parseOrder","order","toArray","update","multi","upsert","flag","key","$set","delete","removeOpt","justOne","remove","count","total","$sum","aggregate","isEmpty","push","$match","$group","$sort","fn","promisify","sum","ensureIndex","indexes","unique","isString","split","isArray","close"],"mappings":"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","file":"mongo.js","sourcesContent":["'use strict';\n\nimport Parse from './_parse_mongo.js';\n\nlet MongoSocket = think.adapter('socket', 'mongo');\n\n/**\n * mongo db class\n */\nexport default class extends Parse {\n  /**\n   * init\n   * @param  {Object} config []\n   * @return {}        []\n   */\n  init(config){\n    super.init();\n    this.config = config;\n    this.lastInsertId = 0;\n    this._socket = null; //Mongo socket instance\n  }\n  /**\n   * connect mongo socket\n   * @return {Promise} []\n   */\n  socket(){\n    if(this._socket){\n      return this._socket;\n    }\n    this._socket = MongoSocket.getInstance(this.config, thinkCache.DB);\n    return this._socket;\n  }\n  /**\n   * get connection\n   * @return {Promise} []\n   */\n  collection(table){\n    let instance = this.socket();\n    return instance.getConnection().then(db => db.collection(table));\n  }\n  /**\n   * get last insert id\n   * @return {String} []\n   */\n  getLastInsertId(){\n    return this.lastInsertId;\n  }\n  /**\n   * add data\n   * @param {Objec} data    []\n   * @param {Object} options []\n   */\n  async add(data, options){\n    let collection = await this.collection(options.table);\n    let result = await collection.insert(data);\n    this.lastInsertId = data._id.toString();\n    return result;\n  }\n  /**\n   * add multi data\n   * @param {Array} dataList []\n   * @param {Object} options [ {ordered: true}. If false, perform an unordered insert, and if an error occurs with one of documents, continue processing the remaining documents in the array.}]\n   * @param {Object} options  []\n   */\n  async addMany(dataList, options){\n    let collection = await this.collection(options.table);\n    let result = await collection.insert(dataList, options);\n    let insertedIds = dataList.map(item => {\n      return item._id.toString();\n    });\n    this.lastInsertId = insertedIds;\n    return result;\n  }\n  /**\n   * set collection limit\n   * @param  {Object} collection []\n   * @param  {String} limit      []\n   * @return {Object}            []\n   */\n  limit(collection, limit){\n    limit = this.parseLimit(limit);\n    if(limit[0]){\n      collection.skip(limit[0]);\n    }\n    if(limit[1]){\n      collection.limit(limit[1]);\n    }\n    return collection;\n  }\n  /**\n   * parse group\n   * @param  {String} group []\n   * @return {Object}       []\n   */\n  group(group){\n    group = this.parseGroup(group);\n    let length = group.length;\n    if(length === 0){\n      return {_id: null};\n    }else if(length === 1){\n      return {_id: `$${group[0]}`};\n    }else {\n      let result = {};\n      group.forEach(item => {\n        result[item] = `$${item}`;\n      });\n      return result;\n    }\n  }\n  /**\n   * select data\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async select(options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n\n    //get distinct field data\n    let distinct = this.parseDistinct(options.distinct);\n    if(distinct){\n      return collection.distinct(distinct, where);\n    }\n\n    collection = collection.find(where, this.parseField(options.field));\n    collection = this.limit(collection, options.limit);\n    collection = collection.sort(this.parseOrder(options.order));\n    return collection.toArray();\n  }\n  /**\n   * update data\n   * @param  {Object} data    []\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async update(data, options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n\n    let limit = this.parseLimit(options.limit);\n    // updates multiple documents that meet the query criteria. \n    // default only updates one document\n    if(limit[1] !== 1){\n      options.multi = true;\n    }\n\n    // If set to true, creates a new document when no document matches the query criteria. \n    // The default value is false, which does not insert a new document when no match is found.\n    if(!options.upsert){\n      options.upsert = false;\n    }\n\n    //add $set for data\n    let flag = true;\n    for(let key in data){\n      if(key[0] !== '$'){\n        flag = false;\n        break;\n      }\n    }\n    if(!flag){\n      data = {$set: data};\n    }\n\n    // update operator\n    // http://docs.mongodb.org/manual/reference/operator/update/#id1\n    return collection.update(where, data, options);\n  }\n  /**\n   * delete data\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async delete(options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n    let limit = this.parseLimit(options.limit);\n\n    //delete one row\n    let removeOpt = {};\n    if(limit[1] === 1){\n      removeOpt.justOne = true;\n    }\n    \n    return collection.remove(where, removeOpt);\n  }\n  /**\n   * get count\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async count(options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n\n    let group = this.group(options.group);\n    group.total = {$sum: 1};\n\n    let order = this.parseOrder(options.order);\n\n    let aggregate = [];\n    if(!think.isEmpty(where)){\n      aggregate.push({$match: where});\n    }\n    aggregate.push({$group: group});\n    if(!think.isEmpty(order)){\n      aggregate.push({$sort: order});\n    }\n    //make aggregate method to be a promise\n    let fn = think.promisify(collection.aggregate, collection);\n    return fn(aggregate).then(data => {\n      return data[0] && data[0].total || 0;\n    });\n  }\n  /**\n   * get sum\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async sum(options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n\n    let group = this.group(options.group);\n    group.total = {$sum: `$${options.field}`};\n\n    let order = this.parseOrder(options.order);\n\n    let aggregate = [];\n    if(!think.isEmpty(where)){\n      aggregate.push({$match: where});\n    }\n    aggregate.push({$group: group});\n    if(!think.isEmpty(order)){\n      aggregate.push({$sort: order});\n    }\n    //make aggregate method to be a promise\n    let fn = think.promisify(collection.aggregate, collection);\n    return fn(aggregate).then(data => {\n      return data[0] && data[0].total || 0;\n    });\n  }\n  /**\n   * create collection indexes\n   * @param  {String} table   []\n   * @param  {Object} indexes []\n   * @return {Promise}         []\n   */\n  ensureIndex(table, indexes, options = {}){\n    if(options === true){\n      options = {unique: true};\n    }\n    if(think.isString(indexes)){\n      indexes = indexes.split(/\\s*,\\s*/);\n    }\n    if(think.isArray(indexes)){\n      let result = {};\n      indexes.forEach(item => {\n        result[item] = 1;\n      });\n      indexes = result;\n    }\n    return this.collection(table).then(collection => {\n      return collection.ensureIndex(indexes, options);\n    });\n  }\n  /**\n   * aggregate\n   * @param  {String} table   []\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  aggregate(table, options){\n    return this.collection(table).then(collection => {\n      let fn = think.promisify(collection.aggregate, collection);\n      return fn(options);\n    });\n  }\n  /**\n   * close socket\n   * @return {} []\n   */\n  close(){\n    if(this._socket){\n      this._socket.close();\n      this._socket = null;\n    }\n  }\n}"]}